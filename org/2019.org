#+HUGO_BASE_DIR: ../
#+HUGO_SECTION: ./posts
#+OPTIONS: author:nil

* DONE 2018 in Review
:PROPERTIES:
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :date 2019-01-03 :slug 2018-in-review
:END:

** DONE en
:PROPERTIES:
:EXPORT_TITLE: 2018 in Review
:EXPORT_FILE_NAME: 2019-01-03-2018-in-review.en.md
:END:

Before anything, happy New Year!

It's an interesting feeling when the time span of one year gradually becomes
shorter relative to the time that has already passed in one's life. If only the
actual length of one year also scales with one's age, perhaps we would feel more
of the excitement instead of anxiety during the New Year count down. That being
said, 2018 was a lot of fun for me, even without ray-tracing graphic cards.

*** The Amazing 2018
To quote my 2017 self:

#+BEGIN_QUOTE
If I've learned anything from my past failed plans, it would be to always
underestimate my own capabilities when planning...
#+END_QUOTE

Yeah, it's totally just that my estimates about the amount of free time I would
have was off, as can be seen from the status of my 2018 goals.

- [ ] Run 1000 miles. [405/1000]
- [ ] Finish a marathon.
- [ ] Write 20 blog posts. [10/20]
- [ ] Get the first signature for my PGP key.
- [ ] Install Gentoo.

Knowing that I can always change the 'publish date' of blog entries (thanks to
=hugo=), I grew into the bad habit of starting an article and just then shelving
it for months to come. When I finally remember that one unfinished article, I
frequently dismiss the idea as not really worth elaborating. Now that I think
about it, maybe this is exactly what blogs are for, providing a snapshot of
myself that I can look back later, whether my future self find it silly or 'not
really worth elaborating'.

The number of movie theater visits I had in 2018 probably accounts for 50% of my
lifetime total, and with double doses of disappointment from /Star Wars: The
Last Jedi/ and /Incredibles 2/. By the way, 2018 also saw 90% of my lifetime
popcorn consumption. I've never realized those can be such addicting.

Although not a marathon, I did ran my first trail half marathon in May. It was
the first time I've ever hit the wall while running, due to bad pacing and
unpreparedness for the weather. The race started mid afternoon on a scorchingly
hot day. After witnessing quite a few people stopped to walk in the first 2
miles, I started off quite a bit faster than my intended pace fueled by a stupid
sense of superiority, and hit the wall right at the mark of 4 miles. Fortunately
the feeling faded away as I walked the next half of the race, gulping ice-cold
Gatorade at every hydration point. However, the ice-cold Gatorade was another
trap—temperature dropped rapidly as sun started to set and my stomach started
to complain about all the chilly liquid. As the finish line appeared within 400
meters of my sight, my legs were hit by the strongest cramps I've ever
had. After barely making it through while being surpassed by 3 people right
before finish line, I could only be happy to learn that I was still not the last
one: actually, I'm even the first one in my age group (+whose size is one+). The
somewhat illegitimate feeling of compliment, mixed with a bit of salt and guilt
made the race a wondrous experience.

*** The Spectacular 2019
Since Google is deprecating Inbox in the coming March, I've lost my last excuse
for clinging to Gmail. I'll try to gradually fade out my Gmail usage for my own
email server.

On the front of searching for best solution for blog comments, quite a few
bloggers I follow have started embracing the [[https://indieweb.org/][IndieWeb]] and [[https://webmention.net/][Webmention]]
standards. In a lot of ways, Webmention was the exact thing I wanted: federated
blog comments, posts, and more. Yet I'm reluctant to move further away from a
static site, not to mentioning most easy-to-follow Webmention solutions I have
found relies heavily on third-party services. The IndieWeb standard though is
fairly intriguing. I've never had much use for [[https://keybase.io/][Keybase]] aside from it being a hub
linking most of my online presences (decryption and encryption does not work
without uploading PGP private keys, and I have no one to securely chat with),
perhaps I should just replace it with =rel=me= links.

Diving into C++17 was fairly enjoyable during the past year, so I'm looking into
learning other new programming languages. [[https://www.rust-lang.org/][Rust]] and [[https://julialang.org/][Julia]] have been on my radar
for a while, especially Rust. Having a full suite of officially supported tools
makes writing Rust a smooth and deeply satisfying experience. I'll try to dive
deeper into both languages and hopefully put them into some uses.

As for running and blog posts, I'll try to match 2018's numbers. On top of
those, I'm thinking about keeping a record of the books, music, and shows I've
read/listened/watched on this blog, along with my thoughts. I actually attempted
something similar during this blog's Wordpress days: I once setup a MediaWiki
instance for similar purposes, but lacked the motivation to continue maintaining
the entries. I'll keep it simple this time, and I should come up with a set of
rating system.

What should I do with the remaining 2018 goals? A separate wishlist is a pretty
good idea—let's go with that. As a stretch goal, I should probably clean my
desktop computer, which is stuffed with four-year-old dirt, cat hair, and dead
skin cells.

Here's to another spectacular 2.9e+17 radiation periods of Caesium-133!

** DONE zh
:PROPERTIES:
:EXPORT_TITLE: 回顾 2018
:EXPORT_FILE_NAME: 2019-01-03-2018-in-review.zh.md
:END:

新年快乐！

一年时间的相对长度比起一个人已经度过的时间总是在不停地缩短。如果一年的长度也随着人的年龄增长的话，我们在新年倒计时中的感受大概会有更多的兴奋而非焦虑和不安吧。话说回来，就算没有光追显卡， 2018 年对我来说也很有趣。

*** The Amazing 2018
引用 2017 年的自己：

#+BEGIN_QUOTE
如果我有从过去那些我制定后没能执行的计划里得到任何经验的话，那就是定计划时最好稍微低估自己的能力...
#+END_QUOTE

是的，从我 2018 年目标的完成状态可以看出，一定是空闲时间的估计上了的问题。嗯，一定是这样。

- [ ] 跑 1000 英里。[405/1000]
- [ ] 完成一次马拉松。
- [ ] 写 20 篇以上的日志。[10/20]
- [ ] 获得第一个 PGP 密匙签名。
- [ ] 安装 Gentoo。

由于使用 =hugo= ，我可以随时更改博客条目的“发布日期”，我养成了撰写文章开头后将其搁置好几个月的坏习惯。当我最后记得那篇未完成的文章时，我经常认为这个想法不值得详细写下去。现在想想，也许这正是博客的目的，它提供了我在某个时间点的快照，使得我可以回顾过去的自己，无论将来的我会觉得这是愚蠢的还是“不值得详细写下去”的。

我在 2018 年的电影院访问次数可能占我一生的总数的 50 ％，但平均失望程度却因为 /星球大战：最后的绝地武士/ 和 /超人总动员 2/ 而翻倍。 顺便一提，2018 年的爆米花消费量也达到了我一生总量的 90 ％。我从来没有意识到爆米花会如此令人上瘾。

尽管不是全程马拉松，但我在 5 月参加了第一次山地半程马拉松比赛。这是我第一次在跑步时感到体力不支，原因是配速不佳以及对天气的准备不足。比赛当天极其炎热，且比赛从下午开始。在目睹许多人在头 2 英里内停下来走路后，由于愚蠢的虚荣心作祟，我的初始速度比我预期的速度要快得多，并在 4 英里的时候不得不因为体力不支停下。所幸，在我走完接下来的一半赛程并在每个补给点大量补充佳得乐后，疲劳的感觉消失了。但是，我没想到那些佳得乐会是另一个陷阱，太阳落山的同时带着气温迅速下降，我的胃开始因为摄入太多冰冷的液体而开始抽搐。当终点线出现在距我视线 400 米以内的地方时，我的双腿受到了我有史以来最强烈的抽筋的打击。在距离终点一步之遥的地方连续被 3 个人超越之后，我终于勉强完成了比赛，但我很高兴得知自己还不是最后一名：实际上，我甚至是我这个（ +大概只有一个人完赛的+ ）年龄组中的第一名。来的名不正言不顺的第一名带来的喜悦，混杂着一点点的不甘心和罪恶感，使那场比赛成为了一次奇妙的经历。

*** The Spectacular 2019
由于 Google 即将在 3 月淘汰 Inbox ，我失去了继续使用 Gmail 的最后借口。 我将逐渐淡化 Gmail 的使用，转向我自己的电子邮件服务器。

说到博客评论的最佳解决方案，我关注的许多博客作者已经开始使用 [[https://indieweb.org/][IndieWeb]] 和 [[https://webmention.net/][Webmention]] 标准。在很多方面， Webmention 正是我想要的东西：它提供了分布式的博客评论、日志等等。 但是，我不愿舍弃静态站点的好处，更不用说我发现大多数易于遵循的 Webmention 解决方案都严重依赖第三方服务。 IndieWeb 标准倒是很吸引人。说起来我的 [[https://keybase.io/][Keybase]] 除了作为一个联系我不同线上身份的枢纽外并没有太大用处（在线解密和加密功能需要上传 PGP 私钥才能使用，安全消息功能对与并没有什么人可以聊天的我更是派不上用场），也许我应该用 =rel=me= 链接来完全取代它。

去年学习 C++17 的体验非常令人享受，因此我正在考虑学习其他新的编程语言。我已经窥觎 [[https://www.rust-lang.org/][Rust]] 和 [[https://julialang.org/][Julia]] 一段时间了，尤其是 Rust 。拥有一整套官方支持的工具链使写 Rust 变得顺畅而愉快。我会尝试深入了解并实际使用这两种语言。

至于跑步和博客日志，我将尝试维持 2018 年的数字。除此之外，我考虑在博客上记录看/听/读过的书籍，音乐和节目，以及自己的想法。过去在本站的 Wordpress 时代，我有过类似的尝试：我搭建了一个 MediaWiki 实例来记录这些，但缺乏继续维护条目的动力。这次我会用一些更轻量的解决办法，并且构思一套评分系统。

我应该如何处理其余的 2018 年目标呢？单独的愿望清单是一个很好的主意。作为一个额外目标，我应该清理一下那台堆积了四年份灰尘、猫毛和死皮细胞的台式机。

为接下来的 2.9e+17 个铯 133 辐射周期干杯！

* DONE Installing Gentoo
:PROPERTIES:
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :date 2019-01-27 :slug installing-gentoo
:END:

** DONE en
:PROPERTIES:
:EXPORT_TITLE: Installing Gentoo
:EXPORT_FILE_NAME: 2019-01-27-installing-gentoo.en.md
:END:

I finally bite the bullet and installed Gentoo on VirtualBox (totally not motivated by the front page wishlist), thereby achieving my ultimate digital @5c3n510n (or descent according to DistroWatch).

Jokes aside, the installation process is surprisingly pleasant: the [[https://wiki.gentoo.org/wiki/Handbook:Main_Page][Gentoo Handbook]] is wonderfully written, and seems to have a plan for everything that might go wrong. I like the Handbook more than ArchWiki's [[https://wiki.archlinux.org/index.php/Installation_guide][Installation Guide]] as it also details the rationale behind each step I took, which is often a fun read in its own right. I would go as far as saying the Gentoo Handbook is actually more beginner friendly, as it carefully assembles bits of information that are normally scattered all over the place, providing a great starting point for learning how to tame the operating system. Besides, Gentoo Handbook covers more than installation: it also contains other necessary setup processes to set up a usable system. I will be gradually replicating my current desktop setup to decide if a migration is worth the time.

My very first encounter with GNU/Linux operating systems is Ubuntu 12.04: one of my classmates (vacuuny/A2Clef) was installing it in school's computer labs. There was a time when I would switch between various Ubuntu variants every few days. I dual booted Windows and Ubuntu for a while before switching entirely to Ubuntu in 2014. Much annoyed by the Amazon ads, I tried out Arch Linux as part of my New Year's resolution in 2015. Even with a second computer to look up instructions, it still took me quite a while to adapt to the new system. I ranted "maybe I still haven't gotten the Arch way" in my old blog, but never looked back once I got the knack of it.

I still try out other distributions from time to time in VirtualBox, but never find them to offer much improvements compared with Arch beyond the setup processes, and even more so when considering the excellent documentation on ArchWiki (well now we have a contender). Once I have my desktop environment set up, the experience between distributions is not that different, but the distinctions kicks in when problems occur and I search online for troubleshooting tips. Having more up-to-date packages is another charm Arch has. More recently, the =systemd= controversy caused me to start shopping around for a new distribution to try out, not so much because of the actual security concerns, but just to see what it is like to use different init system: my time in Ubuntu was spent mostly in GUIs (=apt-get= and =nano= was probably the only command I knew for the longest time) without knowing about init systems and Arch was already using =systemd= when I switched. Aside from Gentoo, the candidates include Void Linux and the BSDs. Void Linux was easy to set up with its installer wizard, yet I didn't feel compelled to move to it. Let's see if Gentoo would change my mind.

** DONE zh
:PROPERTIES:
:EXPORT_TITLE: 安装 Gentoo
:EXPORT_FILE_NAME: 2019-01-27-installing-gentoo.zh.md
:END:

我终于下定决心在 VirtualBox 上尝试了安装 Gentoo（绝对不是因为首页的愿望清单），从而实现了我的终极数字飞升（按照 DistroWatch 排名的话应该是下凡）。

话说回来，安装过程十分顺畅： [[https://wiki.gentoo.org/wiki/Handbook:Main_Page][Gentoo 手册]] 编写的很出色，似乎预料到了所有可能出错的地方并准备好了后备反感。与 ArchWiki 的 [[https://wiki.archlinux.org/index.php/Installation_guide][安装指南]] 相比，我更喜欢该手册，因为手册还详细介绍了我采取的每一步背后的原因。我甚至觉得，Gentoo 手册实际上是对初学者更友好的，因为它精心汇总了了通常散布在各处的信息，为学习如何驯服你的操作系统提供了一个很好的起点。 此外， Gentoo 手册不仅涉及安装，还包含其他设置一个可用的系统的必要步骤。我将逐步复制我当前的台式机设置，以决定是否值得进行迁移。

我第一次接触 GNU/Linux 操作系统是 Ubuntu 12.04 ：我的一位同学（ vacuuny/A2Clef ）在学校的计算机实验室中安装了它。曾经有一段时间我每隔几天会在各种 Ubuntu 版本之间进行切换。在同时使用 Windows 和 Ubuntu 一段时间后，我在 2014 年完全切换到 Ubuntu 。由于 Ubuntu 上亚马逊广告的猖獗，我尝试了 Arch Linux ，作为 2015 年新年计划的一部分。即使有第二台计算机来查找说明，我也花了相当长的时间来适应新系统。我在旧博客中还曾写到“大概我还没有 get 到 the Arch way ”。但是完全熟悉 Arch Linux 后，我就再也没有回头。

我仍然会不时在 VirtualBox 中尝试其他发行版，但是除了设置过程之外，我从未发现它们与 Arch 相比能够提供多少改进，更不用提 ArchWiki 上极为出色的文档（现在我们有一个竞争者了）。设置好桌面环境后，发行版之间的体验并没有太大区别，但是当我遇到问题并在线搜索如何故障排除时，区别就开始出现了。拥有更多、更新的软件包是 Arch 的另一项魅力。最近，关于 =systemd= 的争议使我开始四处寻找新发行版以进行试用。与其说是因为实际的安全问题，不如说我只是想试试使用不同的初始化系统：在 Ubuntu 下我主要使用图形界面（ =apt-get= 和 =nano= 可能是我很长一段时间里知道的唯二命令）所以并没有什么直观感受，而在我换用 Arch 时， Arch 已经在使用 =systemd= 了。除了 Gentoo ，候选对象还包括 Void Linux 和 BSD 。 Void Linux 有易于使用的安装向导，但我并不感到它有特别吸引我的地方。看看 Gentoo 是否会改变我的想法。

* DONE Trackpad and Swollen Batteries
:PROPERTIES:
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :date 2019-02-28 :slug trackpad-and-swollen-batteries
:END:

** DONE en
:PROPERTIES:
:EXPORT_TITLE: Trackpad and Swollen Batteries
:EXPORT_FILE_NAME: 2019-02-28-trackpad-and-swollen-batteries.en.md
:END:

For the last few weeks, the right click on my Dell XPS 13's trackpad is getting less responsive: the entire right half of the trackpad sunk around 2mm beneath the palm rest, making clicks hard to register. At first I dismissed it as normal wear, but it turned out that the swollen batteries lifted the left half of the trackpad to such a degree that the trackpad warped. I immediately ordered an OEM replacement (Dell JD25G) swapped out the swollen batteries. XPS 13 (9343) was a breeze to service. The screws that hold the bottom panel (a quite hefty hunk of aluminum) in place are all clearly visible and the component layout allows battery to be swapped with minimal disassembly. I also swapped out the WLAN card (Dell DW1560) for an Intel AC9560, whose drivers are in the mainline Linux kernel.

The trackpad felt normal after the battery swap, of course. However, the fact that average laptop battery starts to degrade around 18 months surprised me quite a bit. Mine lasting nearly four years is probably quite decent. Newer laptops uses prismatic cells (those slab shaped batteries also found in phones) instead of cylindrical ones, as can be found in my first laptop, Dell Vostro 3750. Roughly speaking, prismatic cells trade size for lifespan by emitting external casing and gas vents found on cylindrical cells. The battery swell is caused by gas build up, which might have been avoided in cylindrical cells with vents. It's interesting that (easily) removable batteries have largely disappeared in consumer laptops - even the large desktop replacements (to be fair, those spend most of the time plugged in anyways). The only consumer electronics that still almost always have removable batteries I can think of are cameras.

After the incident, I started to browse current laptops on the market as the new quad/hex core laptop CPUs are quite tempting an upgrade (my XPS 13 has a i5-5200U). I was not a huge fan of the latest XPS 13 (9380) mostly because of the port selection: I just don't have any USB Type-C devices, so the 1 Type-C plus 2 Type-A combination found on XPS 13 (9360) is superior in my opinion. Besides ports, the onboard WLAN card and removal of full-sized SD card slot also make the latest model less appealing.

I also came across the Let's Note line of laptops from Panasonic, which are reliable, lightweight business laptops that often comes with removable batteries and a wide spectrum of ports. If only they weren't so prohibitively expansive, doesn't have those ugly "Wheel Pads", and come with US keyboard layout, they are quite the ideal laptops. I like the aesthetics of 2016 CF-MX5 series the most, but that won't make much of an upgrade.

More realistic choices include HP's EliteBook, Lenovo's ThinkPad T series, and Dell's Latitude/Precision lines. I vetoed EliteBook because all of them had a huge glaring proprietary docking port that I might never use. Latitude 5491 seem to have cooling issues due to the 45W TDP CPUs, while Latitude 7390 and 7490 both seem quite decent, with options to disable Intel ME and official Linux support. ThinkPad T480 pretty much ticks everything on my list, but it seems that the next iteration T490 will no longer have the bridge battery system and only one SODIMM slot, pretty much like T480s.

Hunting for second-handed machines is also an option, but it defeats the purpose of the upgrade since my primary motivation is the new quad core CPUs. Some may argue our laptops are overpowered already, and indeed my XPS 13 still feels pretty snappy though, so I'm not in urgent need for an upgrade. However, I did come up with a list of what I want in a laptop in case the ideal candidate shows up someday.
- Good Linux driver support.
- Below 15 inch in size and low travel weight. XPS 13 converted me from a DTR enthusiast to an Ultrabook follower: it does feel nice to be able carry a laptop all day without feeling it.
- Non-Nvidia graphics. Both AMD and Intel has better open source driver support and I use my desktop for tasks heavily reliant on GPU.
- Reasonable battery life (6 hours or more) and removable battery.
- Not-too-radical port selections, not until all mouses and flash drives default to USB Type-C at least.
- Standard components and easy to upgrade, i.e. SODIMM slot for memory, PCIe for WLAN card/SSD.
- A nice trackpad. I'm rather insensitive to quality of laptop keyboards so anything marginally decent would do. It would be really cool to have an ErgoDox laptop though.
- Not-super-high-resolution display. I'm not too picky about screens either, but 4K feels like an utter overkill for laptops this size that provides marginal improvements while draining more power. I've always used 16:9 displays, but I'm open to trying out different ones.

** DONE zh
:PROPERTIES:
:EXPORT_TITLE: 触摸板和膨胀的电池
:EXPORT_FILE_NAME: 2019-02-28-trackpad-and-swollen-batteries.zh.md
:END:

在过去的几周中，我的 Dell XPS 13 触控板右键变得越来越难以使用：整个触控板的右半部分沉入了掌托下方约 2mm 的位置，使右击难以被记录。最初我认为是正常磨损，但事实上是膨胀的电池将触控板的左半部分拱起，导致触摸板变形。 我立即订购了 OEM 部件（ Dell JD25G ），更换了膨胀的电池。XPS 13 （ 9343 ）还算易于维修。固定底板（相当大的一块铝块）的螺钉都清晰可见，并且组件布局允许在打开底板后直接更换电池。 我还将无线网卡（ Dell DW1560 ）换成了 Intel AC9560，其驱动程序在主线 Linux 内核中，方便不少。

更换电池后，触控板恢复了正常。但是，笔记本电脑电池平均在 18 个月左右开始性能下降这一事实仍使我感到非常惊讶。 我这块持续了近四年的电池已经算不错了。较新的笔记本电脑大多使用方形电芯（它们也被用在智能手机中的平板状电池里），而非我的第一台笔记本电脑 Dell Vostro 3750 中搭载那种的圆柱形电芯。电池膨胀一般是由气体积聚引起的，这在带有通风孔的圆柱形电芯中可以避免。有趣的是，可拆卸电池在消费类笔记本电脑中已基本消失 - 即使是大型的台式机替代品（虽然这些笔记本电脑大部分时间都插在电源上）。我能想到的唯一仍然几乎总是具有可拆卸电池的消费电子产品是相机。

这一事件之后，我开始浏览当前市面上的笔记本电脑，因为带有新的四、六核心 CPU 的笔记本电脑是极具诱惑力的升级（我的 XPS 13 配置了 i5-5200U ）。我不怎么喜欢最新版本的 XPS 13（9380），主要是因为端口选择：我目前没有任何 USB Type-C 设备，因此我认为 XPS 13 （9360）上的一个 Type-C 加两个 Type-A 的组合更加优越。除了端口之外，板载无线网卡和全尺寸 SD 卡插槽的移除也使最新型号的吸引力降低。

我还查看了 Panasonic 的 Let's Note 系列笔记本电脑。这些笔记本电脑是可靠而轻便的商务笔记本电脑，并通常配备可拆卸电池和各种端口。如果要是它们没有那么夸张的价格、没有那些丑陋的“ Wheel Pad ”、并配备美式键盘布局，那它们就是理想的笔记本电脑。我最喜欢 2016 年推出的 CF-MX5 系列的外观，但这一系列的性能比起我目前的配置并不会有多大提升。

更为现实的选择包括惠普的 EliteBook ，联想的 ThinkPad T 系列和戴尔的 Latitude 、 Precision 系列。 我否决了 EliteBook ，因为系列所有机器上都有一个巨大的、我可能永远不会使用的专用坞站端口。由于采用了设计功耗 45W 的 CPU， Latitude 5491 似乎有散热问题，但 Latitude 7390 和 7490 看起来都不错，不仅可以禁用 Intel ME 还带有官方 Linux 支持。 ThinkPad T480 几乎满足了我的所有要求，但下一次代的 T490 似乎将不再具有桥接电池系统并仅保留一个 SODIMM 插槽，与 T480s 差不多。

寻找二手机器也是一种选择，但是由于我的主要动机是购买新的四核 CPU ，所以这达不到升级的目的。 有的人认为我们的笔记本电脑的处理性能早已超过我们的日常需求，况且我的 XPS 13 使用时确实感觉不慢，因此我并不急需进行升级。不过我还是列了一下我对理想中笔记本电脑的需求，以备万一。
- 良好的 Linux 驱动程序支持。
- 尺寸小于 15 英寸，旅行重量轻。 XPS 13 将我从 DTR 爱好者转变为 Ultrabook 追随者：能够整天携带笔记本电脑而几乎感觉不到重量非常棒。
- 非 Nvidia 显卡。 AMD 和 Intel 都具有更好的开源驱动程序支持，而且高度依赖 GPU 的任务还有台式机可以分担。
- 合理的电池寿命（ 6 小时或更长时间）和可拆卸电池。
- 不过于激进的接口选择，至少直到所有鼠标和闪存驱动器默认接口都为 USB C 型的那一天。
- 使用标准组件，易于升级，例如内存使用 SODIMM 插槽、无线网卡和硬盘使用 PCIe 等等。
- 不错的触控板。我对笔记本电脑键盘的质量不太敏感，任何质量尚可的键盘我都能接受。不过要是有搭载 ErgoDox 的笔记本电脑就好了。
- 非超高分辨率的显示屏。我对屏幕也不是很挑剔，但是对于这种大小的笔记本电脑来说，采用 4K 分辨率完全是高射炮打蚊子。我通常使用 16：9 比例的屏幕，但不反对尝试其他分辨率比例。

* DONE enumerate() with C++
:PROPERTIES:
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :date 2019-04-27 :slug enumerate-with-c-plus-plus
:END:

** DONE en
:PROPERTIES:
:EXPORT_TITLE: enumerate() with C++
:EXPORT_FILE_NAME: 2019-04-27-enumerate-with-c-plus-plus.en.md
:END:

Quite a few programming languages provide ways to iterate through a container while keeping count of the number of steps taken, such as =enumerate()= in Python:
#+BEGIN_SRC python
  for i, elem in enumerate(v):
      print(i, elem)
#+END_SRC
and =enumerate()= under =std::iter::Iterator= trait in Rust:
#+BEGIN_SRC rust
  for (i, elem) in v.iter().enumerate() {
      println!("{}, {}", i, elem);
  }
#+END_SRC
This is just a quick note about how to do similar things in C++17 and later without declaring extra variables out of the for loop's scope.

The first way is to use a mutable lambda:
#+BEGIN_SRC c++
  std::for_each(v.begin(), v.end(),
                [i = 0](auto elem) mutable {
                    std::cout << i << ", " << elem << std::endl;
                    ++i;
                });
#+END_SRC
This could be used with all the algorithms that guarantees in-order application of the lambda, but I don't like the dangling =++i= that could get mixed up with other logic.

The second way utilizes structured binding in for loops:
#+BEGIN_SRC c++
  for (auto [i, elem_it] = std::tuple{0, v.begin()}; elem_it != v.end();
       ++i, ++elem_it) {
      std::cout << i << ", " << *elem_it << std::endl;
  }
#+END_SRC
We have to throw in =std::tuple= as otherwise compiler would try to create a =std::initializer_list=, which does not allow heterogeneous contents.

The third least fancy method is to just calculate the distance every time:
#+BEGIN_SRC c++
  for (auto elem_it = v.begin(); elem_it != v.end(); ++elem_it) {
      auto i = std::distance(v.begin(), elem_it);
      std::cout << i << ", " << *elem_it << std::endl;
  }
#+END_SRC
Since we have to copy paste the starting point twice, I like other counter based approaches better.

In C++20, we have the ability to add an init-statement in ranged-based for loops, so we can write something like
#+BEGIN_SRC c++
  for (auto i = 0; auto elem : v) {
      std::cout << i << ", " << elem << std::endl;
      i++;
  }
#+END_SRC
Meh, not that impressive. The new =<ranges>= library provides a more appealing way to achieve this:
#+BEGIN_SRC c++
  for (auto [i, elem] : v | std::view::transform(
           [i = 0](auto elem) mutable { return std::tuple{i++, elem}; })) {
      std::cout << i << ", " << elem << std::endl;
  }
#+END_SRC

I like the structured binding method and the =<ranges>= based method the most. It would be even better though if we can get a =std::view::enumerate= to solve this problem once and for all.

** DONE zh
:PROPERTIES:
:EXPORT_TITLE: 用 C++ 来 enumerate()
:EXPORT_FILE_NAME: 2019-04-27-enumerate-with-c-plus-plus.zh.md
:END:

不少编程语言都提供了在迭代容器的同时记录步数的方法，例如 Python 的 =enumerate()= ：
#+BEGIN_SRC python
  for i, elem in enumerate(v):
      print(i, elem)
#+END_SRC
以及 Rust 里 =std::iter::Iterator= 特性下的 =enumerate()= ：
#+BEGIN_SRC rust
  for (i, elem) in v.iter().enumerate() {
      println!("{}, {}", i, elem);
  }
#+END_SRC
这里记录了如何在 C++17 或更新的标准里尽量简洁地实现类似功能的办法。


第一种方法是使用一个可变的 lambda ：
#+BEGIN_SRC c++
  std::for_each(v.begin(), v.end(),
                [i = 0](auto elem) mutable {
                    std::cout << i << ", " << elem << std::endl;
                    ++i;
                });
#+END_SRC
这个方法使用于所有能够保证 lambda 有序执行的算法，但是我并不喜欢末尾很可能被混入其他逻辑的 =++i= 。

第二种方法是在 for 循环中使用结构化绑定：
#+BEGIN_SRC c++
  for (auto [i, elem_it] = std::tuple{0, v.begin()}; elem_it != v.end();
       ++i, ++elem_it) {
      std::cout << i << ", " << *elem_it << std::endl;
  }
#+END_SRC
为了不让编译器默认创建只允许同种内容的 =std::initializer_list= ，我们必须加上 =std::tuple= 。

第三种最朴实无华的办法是在循环的每一步计算指针距离：
#+BEGIN_SRC c++
  for (auto elem_it = v.begin(); elem_it != v.end(); ++elem_it) {
      auto i = std::distance(v.begin(), elem_it);
      std::cout << i << ", " << *elem_it << std::endl;
  }
#+END_SRC
由于这种方法需要我们在两个地方指定初始指针，我更喜欢之前提到的基于计数器的方法。

在 C++20 中，我们可以在基于范围的 for 循环中加入初始化语句：
#+BEGIN_SRC c++
  for (auto i = 0; auto elem : v) {
      std::cout << i << ", " << elem << std::endl;
      i++;
  }
#+END_SRC
新加入的 =<ranges>= 库则提供了一种更加吸引人的实现方法：
#+BEGIN_SRC c++
  for (auto [i, elem] : v | std::view::transform(
           [i = 0](auto elem) mutable { return std::tuple{i++, elem}; })) {
      std::cout << i << ", " << elem << std::endl;
  }
#+END_SRC

我最喜欢基于结构化绑定和 =<ranges>= 库的方法。当然如果要是有 =std::view::enumerate= 来一劳永逸地解决这个问题就最好不过了。

* DONE Hello Darkness, My Old Friend
:PROPERTIES:
:EXPORT_HUGO_CUSTOM_FRONT_MATTER: :date 2019-09-15 :slug hello-darkness-my-old-friend
:END:

** DONE en
:PROPERTIES:
:EXPORT_TITLE: Hello Darkness, My Old Friend
:EXPORT_FILE_NAME: 2019-09-15-hello-darkness-my-old-friend.en.md
:END:

With system wide dark modes becoming commonplace, I took the effort to tweak the color scheme of my blog and added a dark mode specific one using =prefers-color-scheme= in CSS. I also toyed around the idea of adding a user toggle using JavaScript per instructions [[https://flaviocopes.com/dark-mode/][here]], but ultimately decided against it because of my (totally unjustified and groundless) distaste towards the language.

| Color Usage     | Light Theme | Dark Theme |
| Accent          | =#700000=   | =#8fffff=  |
| Background      | =#f7f3e3=   | =#080c1c=  |
| Text            | =#2e2d2b=   | =#d1d2d4=  |
| Code Background | =#e3dacb=   | =#1c2534=  |
| Border 1        | =#e7e3d3=   | =#181c2c=  |
| Border 2        | =#d7d3c3=   | =#282c3c=  |

Writing CSS is a such tiring endeavor, but on the bright side, picking colors is a surprisingly relaxing activity. The light mode color scheme now has reduced contrast, and I updated the isso style sheets with matching colors. Yes, I only inverted the colors in dark mode and did not reduce the font weights because of the peculiar way in which human vision work. Part of me already screams heresy when I look at the color codes formed by three numbers that seem to have no connection whatsoever—they are like dissonant chords that cause itches in brain—so I *need* them to at least sum up to a nice number.

Wissen ist Nacht!

** DONE zh
:PROPERTIES:
:EXPORT_TITLE: 你好黑暗，我的老朋友
:EXPORT_FILE_NAME: 2019-09-15-hello-darkness-my-old-friend.zh.md
:END:

由于越来越多的设备和软件都开始支持暗色模式，我调整了博客的配色并加入了用 CSS 的 =prefers-color-scheme= 实现的暗色主题。我也考虑了加入用户切换的功能（参考 [[https://flaviocopes.com/dark-mode/][这里]] 的教程），但是出于我对 JavaScript （毫无来由）的反感，我最后否定了这个主意。

| 颜色用途 | 亮色主题  | 暗色主题  |
| 强调     | =#700000= | =#8fffff= |
| 背景     | =#f7f3e3= | =#080c1c= |
| 文字     | =#2e2d2b= | =#d1d2d4= |
| 代码背景 | =#e3dacb= | =#1c2534= |
| 边框1    | =#e7e3d3= | =#181c2c= |
| 边框2    | =#d7d3c3= | =#282c3c= |

写 CSS 真是累人，不过好在挑选配色是一件挺让人放松的事。新的亮色主题有更低的对比度，我也更新了 isso 的样式表。是的，我的暗色主题只不过是亮色主题的反色版本，并没有降低文字粗细程度以照顾人类视力的某种古怪特性和其他细微的颜色调整。当我看到由三个似乎没有任何联系的数字形成的颜色代码时，我潜意识已经在大呼异端——它们就像不协和和弦一样让人头皮发麻——所以我 *需要* 它们至少加起来是一个不那么差劲的数。

知识就是黑夜！

* DONE Fun with Fonts on the Web
:PROPERTIES:
:EXPORT_DATE: 2019-12-01
:EXPORT_HUGO_SLUG: fun-with-fonts-on-the-web
:END:

** DONE en
:PROPERTIES:
:EXPORT_FILE_NAME: 2019-12-01-fun-with-fonts-on-the-web.en.md
:EXPORT_TITLE: Fun with Fonts on the Web
:END:

A more accurate version of the title probably should be "Fun with Fonts in Web Browsers", but oh well, it sounds cooler that way. Text rendering is [[https://gankra.github.io/blah/text-hates-you/][hard]], and it certainly doesn't help that we have a plethora of different writing systems (blame the Tower of Babel for that, I guess) which cannot be elegantly fitted into a uniform system. Running a bilingual blog doubles the trouble in font picking, and here's a compilation of the various problems I encountered.

*** Space Invaders
Most browsers join consecutive lines of text in HTML to a single one with an added space in between, so
#+BEGIN_SRC html
  <html>Line one and
  line two.</html>
#+END_SRC
renders to
#+BEGIN_EXAMPLE
Line one and line two.
#+END_EXAMPLE

Such a simplistic rule doesn't work for CJK languages where no separators is used between words. The solution is to specify the =lang= attribute for the page (or any specific element on the page) like so:
#+BEGIN_SRC html
  <html lang="zh">第一行和
  第二行。</html>
#+END_SRC
If your browser is smart enough (like Firefox), it will join the lines correctly. All the Blink based browsers, however, still stubbornly shove in the extra space, so it looks like I will be stuck in unwrapped source files like a barbarian for a bit longer. While not a cure-all solution, specifying the =lang= attribute still have the added benefit of enabling language-specific CSS rules, which comes in handy later.

*** Return of the Quotation Marks
As mentioned in a [[https://www.shimmy1996.com/en/posts/2018-06-24-fun-with-fonts-in-emacs/][previous post]], CJK fonts would render quotation marks as full-width characters, different from Latin fonts. This won't be a problem as long as a web page doesn't try to mix-and-match fonts: just use language specific font-stack.
#+BEGIN_SRC css
  body:lang(en) {
      font-family: "Oxygen Sans", sans-serif;
  }

  body:lang(zh) {
      font-family: "Noto Sans SC", sans-serif;
  }
#+END_SRC
Coupled with matching =lang= attributes, the story would have ended here. Firefox even allows you to specify default fonts on a per language basis, so you can actually get away with just the fallback values, like =sans-serif= or =serif=, and not even bother writing language specific CSS.

However, what if I want to use Oxygen Sans for Latin characters, Noto Sans SC for CJK characters? While seemingly an sensible solution, specifying font stack like so,
#+BEGIN_SRC css
  body:lang(zh) {
      font-family: "Oxygen Sans", "Noto Sans SC", sans-serif;
  }
#+END_SRC
would cause the quotation marks to be rendered using Oxygen Sans, which displays them as half-width characters. The solution I found is to declare an override font with a specified =unicode-range= that covers the quotation marks,
#+BEGIN_SRC css
  @font-face {
      font-family: "Noto Sans SC Override";
      unicode-range: U+2018-2019, U+201C-201D;
      src: local("NotoSansCJKsc-Regular");
  }
#+END_SRC
and revise the font stack as
#+BEGIN_SRC css
  body:lang(zh) {
      font-family: "Noto Sans SC Override", "Oxygen Sans", "Noto Sans SC", sans-serif;
  }
#+END_SRC
Now we can enjoy the quotation marks in their full-width glory!

*** Font Ninja
Font files are quite significant in size, and even more so for CJK ones: the Noto Sans SC font just mentioned is [[https://github.com/googlefonts/noto-cjk/blob/master/NotoSansSC-Regular.otf][over 8MB]] in size. No matter how determined I am to serve everything from my own server, this seems like an utter overkill considering the average HTML file size on my site is probably closer to 8KB. How does all the web font services handle this then?

Most web font services work by adding a bunch of [[https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face][=@font-face=]] definitions into a website's style sheet, which pulls font files from dedicated servers. To reduce the size of files been served, Google Fonts slice the font file into smaller chunks, and declare corresponding =unicode-range= for each chunk under =@font-face= blocks (this is exactly how they handle [[https://fonts.googleapis.com/css?family=Noto+Sans+SC][CJK fonts]]). They also compress the font files into WOFF2, further reducing file size. On the other hand, [[https://fonts.adobe.com/][Adobe Fonts]] (previously known as Typekit) seem to have some JavaScript wizardry that dynamically determines which glyphs to load from a font file.

Combining best of both worlds, and thanks to the fact that this is a static site, it is easy to gather all the used characters and serve a font file containing just that. The tools of choice here would be pyftsubset (available as a component of [[https://pypi.org/project/fonttools/][fonttools]]) and GNU AWK. Compressing font files into WOFF2 also requires Brotli, a compression library. Under Arch Linux, the required packages are [[https://www.archlinux.org/packages/community/any/python-fonttools/][python-fonttools]], [[https://www.archlinux.org/packages/core/x86_64/gawk/][gawk]], [[https://www.archlinux.org/packages/community/x86_64/brotli/][brotli]], and [[https://www.archlinux.org/packages/community/x86_64/python-brotli/][python-brotli]].

Here's a shell one-liner to collect all the used glyphs from generated HTML files:
#+BEGIN_SRC sh
  find . -type f -name "*.html" -printf "%h/%f " | xargs -l awk 'BEGIN{FS="";ORS=""} {for(i=1;i<=NF;i++){chars[$(i)]=$(i);}} END{for(c in chars){print c;} }' > glyphs.txt
#+END_SRC
You may need to =export LANG=en_US.UTF-8= (or any other UTF-8 locale) for certain glyphs to be handled correctly. With the list of glyphs, we can extract the useful part of font files and compress them:
#+BEGIN_SRC sh
  pyftsubset NotoSansSC-Regular.otf --text-file=glyphs.txt --flavor=woff2 --output-file=NotoSansSC-Regular.woff2
#+END_SRC
Specifying =--no-hinting= and =--desubroutinize= can further reduce size of generated file at the cost of some aesthetic fine-tuning. A similar technique can be used to shrink down Latin fonts to include only ASCII characters (or keep the extended ASCII range with =U+0000-00FF=):
#+BEGIN_SRC sh
  pyftsubset Oxygen-Sans.ttf --unicodes="U+0000-007F" --flavor=woff2 --output-file=Oxygen-Sans.woff2
#+END_SRC
Once this is done, available glyphs can be checked using most font manager software, or this [[http://torinak.com/font/lsfont.html][online checker]] (no support for WOFF2 though, but you can convert into other formats first, such as WOFF).

I also played around the idea of actually dividing the glyphs into further chunks by popularity, so here's another one liner to get list of glyphs sorted by number of appearances
#+BEGIN_SRC sh
  find . -type f -name "*.html" -printf "%h/%f " | xargs -l awk 'BEGIN{FS=""} {for(i=1;i<=NF;i++){chars[$(i)]++;}} END{for(c in chars){printf "%06d %s\n", chars[c], c;}}' | sort -r > glyph-by-freq.txt
#+END_SRC
It turns out my blog has around 1000 different Chinese characters, with roughly 400 of them appearing more than 10 times. Since the file sizes I get from directly a single subsetting is already good enough, I didn't bother proceeding with another split.

*** For Your Browsers Only
With all the tricks in my bag, I was able to cut down the combined font file size to around 250KB, still magnitudes above that of an HTML file though. While it is nice to see my site appearing the same across all devices and screens, I feel the benefit is out of proportion compared to the 100-fold increase in page size.

Maybe it is just not worth it to force the choice of fonts. In case you want to see my site as I would like to see it, here are my go-to fonts:
- Proportional Latin font: [[https://github.com/KDE/oxygen-fonts][Oxygen Sans]]. Note that the KDE version has nuanced differences from the [[https://fonts.google.com/specimen/Oxygen][Google Fonts version]], and I like the KDE version much more.
- Proportional CJK font: [[https://www.google.com/get/noto/help/cjk/][Noto Sans CJK]].
- Monospace font: [[https://typeof.net/Iosevka/][Iosevka]], the ss09 variant, to be more exact.

** DONE zh
:PROPERTIES:
:EXPORT_FILE_NAME: 2019-12-01-fun-with-fonts-on-the-web.zh.md
:EXPORT_TITLE: 字体配置万维网篇
:END:

用《字体配置浏览器篇》作为标题或许更为准确，不过现在的标题听起来更吸引人一些。渲染文本 [[https://gankra.github.io/blah/text-hates-you/][不是一件简单的事]] ，如果还要考虑书写系统之间的巨大差异（这大概得怪巴别塔）无异于雪上加霜。运行双语博客会导致字体选择的麻烦加倍，这里是我遇到的一些问题的汇总。

*** 空格侵略者
大多数浏览器会将 HTML 中的连续文本合并为一行，并在链接处加上空格。所以
#+BEGIN_SRC html
  <html>Line one and
  line two.</html>
#+END_SRC
会被渲染为
#+BEGIN_EXAMPLE
Line one and line two.
#+END_EXAMPLE
这种一刀切的方法显然不适用与字符之间不带分隔的 CJK 语言。解决方案是为页面（或页面上的任何特定元素）指定 =lang= 属性，如下所示：
#+BEGIN_SRC html
  <html lang="zh">第一行和
  第二行。</html>
#+END_SRC
如果你的浏览器足够聪明（例如 Firefox），渲染的结果就不会有额外的空格。但是，所有基于 Blink 的浏览器仍然顽固地将多余的空格塞进去，所以我只能像野蛮人那样继续写一段一行的源文件。尽管不是万能的解决方案，但是指定 =lang= 属性仍然具有启用特定于某种语言的CSS规则的额外好处，这稍后会派上用场。

*** 引号归来
如 [[https://www.shimmy1996.com/zh/posts/2018-06-24-fun-with-fonts-in-emacs/][之前的日志]] 所说， CJK 字体会将引号显示为全角字符，不同于拉丁字体。只要网页不尝试混搭字体，这就不会成为问题：只需使用特定于语言的字体栈就行。
#+BEGIN_SRC css
  body:lang(en) {
      font-family: "Oxygen Sans", sans-serif;
  }

  body:lang(zh) {
      font-family: "Noto Sans SC", sans-serif;
  }
#+END_SRC
再加上匹配的 =lang= 属性，所有问题就都解决了。 Firefox 甚至允许为每种语言指定默认字体，所以仅使用后备字体（例如 =sans-serif= 或 =serif= ）也可行，不一定要费心编写特定于语言的CSS。

那么，如果我想用 Oxygen Sans 来渲染拉丁字符，并用 Noto Sans SC 来渲染 CJK 字符怎么办？虽然看似没有问题，但像这样指定字体堆栈，
#+BEGIN_SRC css
  body:lang(zh) {
      font-family: "Oxygen Sans", "Noto Sans SC", sans-serif;
  }
#+END_SRC
会导致引号被 Oxygen Sans 渲染、显示为半角字符。我的解决方案是通过 =unicode-range= 定义一个涵盖了引号的替代字体，
#+BEGIN_SRC css
  @font-face {
      font-family: "Noto Sans SC Override";
      unicode-range: U+2018-2019, U+201C-201D;
      src: local("NotoSansCJKsc-Regular");
  }
#+END_SRC
并修改字体栈为
#+BEGIN_SRC css
  body:lang(zh) {
      font-family: "Noto Sans SC Override", "Oxygen Sans", "Noto Sans SC", sans-serif;
  }
#+END_SRC
这样我们就可以享受全角引号了！

*** 字体忍者
字体文件通常都不小，对于 CJK 字体来说更是如此：刚才提到的 Noto Sans SC 的大小 [[https://github.com/googlefonts/noto-cjk/blob/master/NotoSansSC-Regular.otf][超过8MB]] 。尽管我已经下定主意要从自己的服务器上提供所有文件，考虑到我网站上的平均 HTML 文件大小更接近 8KB，这显得有些过头了。那么那些网络字体服务如何处理这一问题呢？

大多数网络字体服务的工作方式是在网站的样式表里添加一堆 [[https://developer.mozilla.org/zh-CN/docs/Web/CSS/@font-face][=@font-face= ]]定义，以从专用服务器上提取字体文件。为了减少所提供的文件大小， Google Fonts 会将字体文件大卸八块，并在 =@font-face= 里声明每一块所对应的 =unicode-range= （这正是它们处理 [[https://fonts.googleapis.com/css?family=Noto+Sans+SC][CJK 字体]] 的方式）。他们还将字体文件压缩为 WOFF2 以进一步缩减文件大小。而 [[https://fonts.adobe.com/][Adobe Fonts]] （以前称为 Typekit ）似乎有一些 JavaScript 奇技淫巧，可以动态确定要从字体文件加载的字形。

博采众家之长，得益于这是一个静态站点，我们可以简单地统计所有用到的字符，并提供一个只包含这些字符的字体文件。所要用到的工具主要是 pyftsubset （属于 [[https://pypi.org/project/fonttools/][fonttools]] 下的一个组件）和 GNU AWK 。将字体压缩为 WOFF2 还需要 Brotli 压缩库。在 Arch Linux 下，获取这些程序需要安装 [[https://www.archlinux.org/packages/community/any/python-fonttools/][python-fonttools]] 、 [[https://www.archlinux.org/packages/core/x86_64/gawk/][gawk]] 、 [[https://www.archlinux.org/packages/community/x86_64/brotli/][brotli]] 和 [[https://www.archlinux.org/packages/community/x86_64/python-brotli/][python-brotli]] 。

收集生成的HTML文件中的所有使用的字形可以使用这条 shell 命令：
#+BEGIN_SRC sh
  find . -type f -name "*.html" -printf "%h/%f " | xargs -l awk 'BEGIN{FS="";ORS=""} {for(i=1;i<=NF;i++){chars[$(i)]=$(i);}} END{for(c in chars){print c;} }' > glyphs.txt
#+END_SRC
你可能需要 =export LANG=en_US.UTF-8= （或者其他 UTF-8 语言环境）以便正确处理某些字形。有了字形清单，我们就可以提取字体文件的有用部分并进行压缩：
#+BEGIN_SRC sh
  pyftsubset NotoSansSC-Regular.otf --text-file=glyphs.txt --flavor=woff2 --output-file=NotoSansSC-Regular.woff2
#+END_SRC
指定 =--no-hinting= 和 =--desubroutinize= 可以进一步减小生成文件的大小，但会降低字体的美观程度。拉丁字体也可以使用类似的技术来瘦身，例如只提取包含 ASCII 字符的部分（或将范围设为 =U+0000-00FF= 以涵盖 Extended ASCII 字符）：
#+BEGIN_SRC sh
  pyftsubset Oxygen-Sans.ttf --unicodes="U+0000-007F" --flavor=woff2 --output-file=Oxygen-Sans.woff2
#+END_SRC
大部分字体管理器都可以用来检查最后生成文件中可用的字形，也可以使用这一 [[http://torinak.com/font/lsfont.html][在线检查器]] （不支持 WOFF2，但是可以先试着转为其他格式后查看，例如 WOFF）。

我还考虑过将字形按受欢迎程度划分为更多块。获取按出现次数排序的字形列表可以使用以下命令：
#+BEGIN_SRC sh
  find . -type f -name "*.html" -printf "%h/%f " | xargs -l awk 'BEGIN{FS=""} {for(i=1;i<=NF;i++){chars[$(i)]++;}} END{for(c in chars){printf "%06d %s\n", chars[c], c;}}' | sort -r > glyph-by-freq.txt
#+END_SRC
结果显示我的博客用到了大约 1000 个不同的汉字，其中大约 400 个出现了10次以上。由于上一步中获得的字体文件大小已经足够好，我没有继续进行拆分。

*** 孔中窥见真理之貌（好像没有啥不对）
我最终将字体文件的总大小减少到了 250KB 左右，但这仍然比 HTML 文件大好几个数量级。虽然看到我的网站在所有设备和屏幕上都保持一致很让人开心，但是与页面大小增加上百倍的代价相比，我觉得这点好处不成比例。

费劲心思指定字体或许并不值得。如果你希望看到我眼中本站的样子的话，以下是我的常用字体：
- 比例拉丁字体： [[https://github.com/KDE/oxygen-fonts][Oxygen Sans]] 。注意 KDE 版本与 [[https://fonts.google.com/specimen/Oxygen][Google Fonts 版本]] 有一些微妙的区别，我更喜欢前者。
- 比例 CJK 字体： [[https://www.google.com/get/noto/help/cjk/][Noto Sans CJK]] ，即思源黑体。
- 等宽字体： [[https://typeof.net/Iosevka/][Iosevka]] ，确切地说是 ss09 样式。
